<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: trevc: Compute eigenvectors; used by geev</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Routines</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__trevc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">trevc: Compute eigenvectors; used by geev<div class="ingroups"><a class="el" href="group__dense.html">Dense linear algebra</a> &raquo; <a class="el" href="group__group__eigenvalue.html">Eigenvalues</a> &raquo; <a class="el" href="group__group__geev.html">Non-symmetric eigenvalues</a> &raquo; <a class="el" href="group__group__geev__aux.html">Auxiliary routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaabe4c9003c1b68ccea6e5a64875a3e6f"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#gaabe4c9003c1b68ccea6e5a64875a3e6f">magma_ctrevc3</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaFloatComplex *T, magma_int_t ldt, magmaFloatComplex *VL, magma_int_t ldvl, magmaFloatComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaabe4c9003c1b68ccea6e5a64875a3e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTREVC3 computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T.  <a href="#gaabe4c9003c1b68ccea6e5a64875a3e6f">More...</a><br /></td></tr>
<tr class="separator:gaabe4c9003c1b68ccea6e5a64875a3e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab683d09689da0d357666194408411673"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#gab683d09689da0d357666194408411673">magma_ctrevc3_mt</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaFloatComplex *T, magma_int_t ldt, magmaFloatComplex *VL, magma_int_t ldvl, magmaFloatComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gab683d09689da0d357666194408411673"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTREVC3_MT computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T.  <a href="#gab683d09689da0d357666194408411673">More...</a><br /></td></tr>
<tr class="separator:gab683d09689da0d357666194408411673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac9f2433592c0d319569bc477181267"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#ga3ac9f2433592c0d319569bc477181267">magma_dtrevc3</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, double *T, magma_int_t ldt, double *VL, magma_int_t ldvl, double *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga3ac9f2433592c0d319569bc477181267"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTREVC3 computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T.  <a href="#ga3ac9f2433592c0d319569bc477181267">More...</a><br /></td></tr>
<tr class="separator:ga3ac9f2433592c0d319569bc477181267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f51280487b0ce62a08fed05b9e72df"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#ga50f51280487b0ce62a08fed05b9e72df">magma_dtrevc3_mt</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, double *T, magma_int_t ldt, double *VL, magma_int_t ldvl, double *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga50f51280487b0ce62a08fed05b9e72df"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTREVC3_MT computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T.  <a href="#ga50f51280487b0ce62a08fed05b9e72df">More...</a><br /></td></tr>
<tr class="separator:ga50f51280487b0ce62a08fed05b9e72df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35122e49f4ef5652ba8fbf526656a041"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#ga35122e49f4ef5652ba8fbf526656a041">magma_strevc3</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, float *T, magma_int_t ldt, float *VL, magma_int_t ldvl, float *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, float *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga35122e49f4ef5652ba8fbf526656a041"><td class="mdescLeft">&#160;</td><td class="mdescRight">STREVC3 computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T.  <a href="#ga35122e49f4ef5652ba8fbf526656a041">More...</a><br /></td></tr>
<tr class="separator:ga35122e49f4ef5652ba8fbf526656a041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1854d8ce4fe11d8a2b4ea504648df7"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#gaff1854d8ce4fe11d8a2b4ea504648df7">magma_strevc3_mt</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, float *T, magma_int_t ldt, float *VL, magma_int_t ldvl, float *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, float *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaff1854d8ce4fe11d8a2b4ea504648df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">STREVC3_MT computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T.  <a href="#gaff1854d8ce4fe11d8a2b4ea504648df7">More...</a><br /></td></tr>
<tr class="separator:gaff1854d8ce4fe11d8a2b4ea504648df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6ca591a54f2908a00788edf8ba04cd"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#ga9f6ca591a54f2908a00788edf8ba04cd">magma_ztrevc3</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaDoubleComplex *T, magma_int_t ldt, magmaDoubleComplex *VL, magma_int_t ldvl, magmaDoubleComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaDoubleComplex *work, magma_int_t lwork, double *rwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga9f6ca591a54f2908a00788edf8ba04cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZTREVC3 computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T.  <a href="#ga9f6ca591a54f2908a00788edf8ba04cd">More...</a><br /></td></tr>
<tr class="separator:ga9f6ca591a54f2908a00788edf8ba04cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0e1380c51ab50558db79e723795f18"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__trevc.html#ga1f0e1380c51ab50558db79e723795f18">magma_ztrevc3_mt</a> (magma_side_t side, magma_vec_t howmany, magma_int_t *select, magma_int_t n, magmaDoubleComplex *T, magma_int_t ldt, magmaDoubleComplex *VL, magma_int_t ldvl, magmaDoubleComplex *VR, magma_int_t ldvr, magma_int_t mm, magma_int_t *mout, magmaDoubleComplex *work, magma_int_t lwork, double *rwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga1f0e1380c51ab50558db79e723795f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZTREVC3_MT computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T.  <a href="#ga1f0e1380c51ab50558db79e723795f18">More...</a><br /></td></tr>
<tr class="separator:ga1f0e1380c51ab50558db79e723795f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaabe4c9003c1b68ccea6e5a64875a3e6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ctrevc3 </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CTREVC3 computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: </p><pre class="fragment">         T*x = w*x,     (y**H)*T = w*(y**H)
</pre><p>where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. The eigenvector corresponding to the j-th eigenvalue is computed if select[j] = true. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">T</td><td>COMPLEX array, dimension (ldt,n) The upper triangular matrix T. modified, but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>COMPLEX array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>COMPLEX array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected eigenvector occupies one column.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>COMPLEX array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,2*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>float array, dimension (n)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="gab683d09689da0d357666194408411673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ctrevc3_mt </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CTREVC3_MT computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by CHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: </p><pre class="fragment">         T*x = w*x,     (y**H)*T = w*(y**H)
</pre><p>where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation. This uses a multi-threaded (mt) implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. The eigenvector corresponding to the j-th eigenvalue is computed if select[j] = true. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">T</td><td>COMPLEX array, dimension (ldt,n) The upper triangular matrix T. Unlike LAPACK's ctrevc, T is not modified, not even temporarily.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>COMPLEX array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>COMPLEX array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by CHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected eigenvector occupies one column.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>COMPLEX array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,2*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>float array, dimension (n)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="ga3ac9f2433592c0d319569bc477181267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dtrevc3 </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTREVC3 computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by DHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**T)*T = w*(y**T)</p>
<p>where y**T denotes the transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. If w(j) is a real eigenvalue, the corresponding real eigenvector is computed if select(j) is true. If w(j) and w(j+1) are the real and imaginary parts of a complex eigenvalue, the corresponding complex eigenvector is computed if either select(j) or select(j+1) is true, and on exit select(j) is set to true and select(j+1) is set to false. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>DOUBLE PRECISION array, dimension (ldt,n) The upper quasi-triangular matrix T in Schur canonical form.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>DOUBLE PRECISION array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by DHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part, and the second the imaginary part. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>DOUBLE PRECISION array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by DHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,3*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="ga50f51280487b0ce62a08fed05b9e72df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dtrevc3_mt </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTREVC3_MT computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by DHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**T)*T = w*(y**T)</p>
<p>where y**T denotes the transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation. This uses a multi-threaded (mt) implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. If w(j) is a real eigenvalue, the corresponding real eigenvector is computed if select(j) is true. If w(j) and w(j+1) are the real and imaginary parts of a complex eigenvalue, the corresponding complex eigenvector is computed if either select(j) or select(j+1) is true, and on exit select(j) is set to true and select(j+1) is set to false. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>DOUBLE PRECISION array, dimension (ldt,n) The upper quasi-triangular matrix T in Schur canonical form.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>DOUBLE PRECISION array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by DHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part, and the second the imaginary part. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>DOUBLE PRECISION array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by DHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,3*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="ga35122e49f4ef5652ba8fbf526656a041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_strevc3 </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STREVC3 computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by SHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**T)*T = w*(y**T)</p>
<p>where y**T denotes the transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. If w(j) is a real eigenvalue, the corresponding real eigenvector is computed if select(j) is true. If w(j) and w(j+1) are the real and imaginary parts of a complex eigenvalue, the corresponding complex eigenvector is computed if either select(j) or select(j+1) is true, and on exit select(j) is set to true and select(j+1) is set to false. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>REAL array, dimension (ldt,n) The upper quasi-triangular matrix T in Schur canonical form.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>REAL array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by SHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part, and the second the imaginary part. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>REAL array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by SHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>(workspace) REAL array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,3*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="gaff1854d8ce4fe11d8a2b4ea504648df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_strevc3_mt </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STREVC3_MT computes some or all of the right and/or left eigenvectors of a real upper quasi-triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a real general matrix: A = Q*T*Q**T, as computed by SHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by:</p>
<p>T*x = w*x, (y**T)*T = w*(y**T)</p>
<p>where y**T denotes the transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal blocks of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation. This uses a multi-threaded (mt) implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. If w(j) is a real eigenvalue, the corresponding real eigenvector is computed if select(j) is true. If w(j) and w(j+1) are the real and imaginary parts of a complex eigenvalue, the corresponding complex eigenvector is computed if either select(j) or select(j+1) is true, and on exit select(j) is set to true and select(j+1) is set to false. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>REAL array, dimension (ldt,n) The upper quasi-triangular matrix T in Schur canonical form.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>REAL array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by SHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part, and the second the imaginary part. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>REAL array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the orthogonal matrix Q of Schur vectors returned by SHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the first holding the real part and the second the imaginary part. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected real eigenvector occupies one column and each selected complex eigenvector occupies two columns.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">work</td><td>(workspace) REAL array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,3*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="ga9f6ca591a54f2908a00788edf8ba04cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ztrevc3 </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZTREVC3 computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by ZHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: </p><pre class="fragment">         T*x = w*x,     (y**H)*T = w*(y**H)
</pre><p>where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. The eigenvector corresponding to the j-th eigenvalue is computed if select[j] = true. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">T</td><td>COMPLEX_16 array, dimension (ldt,n) The upper triangular matrix T. modified, but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>COMPLEX_16 array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by ZHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>COMPLEX_16 array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by ZHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected eigenvector occupies one column.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>COMPLEX_16 array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,2*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>double array, dimension (n)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
<a class="anchor" id="ga1f0e1380c51ab50558db79e723795f18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_ztrevc3_mt </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>howmany</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZTREVC3_MT computes some or all of the right and/or left eigenvectors of a complex upper triangular matrix T. </p>
<p>Matrices of this type are produced by the Schur factorization of a complex general matrix: A = Q*T*Q**H, as computed by ZHSEQR.</p>
<p>The right eigenvector x and the left eigenvector y of T corresponding to an eigenvalue w are defined by: </p><pre class="fragment">         T*x = w*x,     (y**H)*T = w*(y**H)
</pre><p>where y**H denotes the conjugate transpose of the vector y. The eigenvalues are not input to this routine, but are read directly from the diagonal of T.</p>
<p>This routine returns the matrices X and/or Y of right and left eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the unitary factor that reduces a matrix A to Schur form T, then Q*X and Q*Y are the matrices of right and left eigenvectors of A.</p>
<p>This uses a Level 3 BLAS version of the back transformation. This uses a multi-threaded (mt) implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaRight: compute right eigenvectors only;</li>
<li>= MagmaLeft: compute left eigenvectors only;</li>
<li>= MagmaBothSides: compute both right and left eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">howmany</td><td>magma_vec_t<ul>
<li>= MagmaAllVec: compute all right and/or left eigenvectors;</li>
<li>= MagmaBacktransVec: compute all right and/or left eigenvectors, backtransformed by the matrices in VR and/or VL;</li>
<li>= MagmaSomeVec: compute selected right and/or left eigenvectors, as indicated by the logical array select.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>LOGICAL array, dimension (n) If howmany = MagmaSomeVec, select specifies the eigenvectors to be computed. The eigenvector corresponding to the j-th eigenvalue is computed if select[j] = true. Not referenced if howmany = MagmaAllVec or MagmaBacktransVec.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrix T. n &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">T</td><td>COMPLEX_16 array, dimension (ldt,n) The upper triangular matrix T. Unlike LAPACK's ztrevc, T is not modified, not even temporarily.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldt</td><td>INTEGER The leading dimension of the array T. ldt &gt;= max(1,n).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td>COMPLEX_16 array, dimension (ldvl,mm) On entry, if side = MagmaLeft or MagmaBothSides and howmany = MagmaBacktransVec, VL must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by ZHSEQR). On exit, if side = MagmaLeft or MagmaBothSides, VL contains: if howmany = MagmaAllVec, the matrix Y of left eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*Y; if howmany = MagmaSomeVec, the left eigenvectors of T specified by select, stored consecutively in the columns of VL, in the same order as their eigenvalues. Not referenced if side = MagmaRight.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvl</td><td>INTEGER The leading dimension of the array VL. ldvl &gt;= 1, and if side = MagmaLeft or MagmaBothSides, ldvl &gt;= n.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td>COMPLEX_16 array, dimension (ldvr,mm) On entry, if side = MagmaRight or MagmaBothSides and howmany = MagmaBacktransVec, VR must contain an n-by-n matrix Q (usually the unitary matrix Q of Schur vectors returned by ZHSEQR). On exit, if side = MagmaRight or MagmaBothSides, VR contains: if howmany = MagmaAllVec, the matrix X of right eigenvectors of T; if howmany = MagmaBacktransVec, the matrix Q*X; if howmany = MagmaSomeVec, the right eigenvectors of T specified by select, stored consecutively in the columns of VR, in the same order as their eigenvalues. Not referenced if side = MagmaLeft.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldvr</td><td>INTEGER The leading dimension of the array VR. ldvr &gt;= 1, and if side = MagmaRight or MagmaBothSides, ldvr &gt;= n.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mm</td><td>INTEGER The number of columns in the arrays VL and/or VR. mm &gt;= mout.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mout</td><td>INTEGER The number of columns in the arrays VL and/or VR actually used to store the eigenvectors. If howmany = MagmaAllVec or MagmaBacktransVec, mout is set to n. Each selected eigenvector occupies one column.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>COMPLEX_16 array, dimension (max(1,lwork))</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of array work. lwork &gt;= max(1,2*n). For optimum performance, lwork &gt;= (1 + 2*nb)*n, where nb is the optimal blocksize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>double array, dimension (n)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if info = -i, the i-th argument had an illegal value</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>The algorithm used in this program is basically backward (forward) substitution, with scaling to make the the code robust against possible overflow.</p>
<p>Each eigenvector is normalized so that the element of largest magnitude has magnitude 1; here the magnitude of a complex number (x,y) is taken to be |x| + |y|. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
