<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: stedx: Eigenvalues &amp; vectors of tridiagonal using D&amp;C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Routines</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__stedx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stedx: Eigenvalues &amp; vectors of tridiagonal using D&amp;C<div class="ingroups"><a class="el" href="group__dense.html">Dense linear algebra</a> &raquo; <a class="el" href="group__group__eigenvalue.html">Eigenvalues</a> &raquo; <a class="el" href="group__group__heev.html">Symmetric/Hermitian eigenvalues</a> &raquo; <a class="el" href="group__group__heev__aux.html">Auxiliary routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac0b418257d462b5007c7b4f5d3b6173c"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#gac0b418257d462b5007c7b4f5d3b6173c">magma_cstedx</a> (magma_range_t range, magma_int_t n, float vl, float vu, magma_int_t il, magma_int_t iu, float *d, float *e, magmaFloatComplex *Z, magma_int_t ldz, float *rwork, magma_int_t lrwork, magma_int_t *iwork, magma_int_t liwork, magmaFloat_ptr dwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gac0b418257d462b5007c7b4f5d3b6173c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#gac0b418257d462b5007c7b4f5d3b6173c">More...</a><br /></td></tr>
<tr class="separator:gac0b418257d462b5007c7b4f5d3b6173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058fcc87790b6d51cf1f7d1cf32c5524"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#ga058fcc87790b6d51cf1f7d1cf32c5524">magma_cstedx_m</a> (magma_int_t ngpu, magma_range_t range, magma_int_t n, float vl, float vu, magma_int_t il, magma_int_t iu, float *d, float *e, magmaFloatComplex *Z, magma_int_t ldz, float *rwork, magma_int_t lrwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga058fcc87790b6d51cf1f7d1cf32c5524"><td class="mdescLeft">&#160;</td><td class="mdescRight">CSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga058fcc87790b6d51cf1f7d1cf32c5524">More...</a><br /></td></tr>
<tr class="separator:ga058fcc87790b6d51cf1f7d1cf32c5524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894ce156db4fe17a0997135548f3db20"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#ga894ce156db4fe17a0997135548f3db20">magma_dstedx</a> (magma_range_t range, magma_int_t n, double vl, double vu, magma_int_t il, magma_int_t iu, double *d, double *e, double *Z, magma_int_t ldz, double *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magmaDouble_ptr dwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga894ce156db4fe17a0997135548f3db20"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga894ce156db4fe17a0997135548f3db20">More...</a><br /></td></tr>
<tr class="separator:ga894ce156db4fe17a0997135548f3db20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2db17db761047f9a4f32e57c9c21df"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#ga7a2db17db761047f9a4f32e57c9c21df">magma_dstedx_m</a> (magma_int_t ngpu, magma_range_t range, magma_int_t n, double vl, double vu, magma_int_t il, magma_int_t iu, double *d, double *e, double *Z, magma_int_t ldz, double *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga7a2db17db761047f9a4f32e57c9c21df"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga7a2db17db761047f9a4f32e57c9c21df">More...</a><br /></td></tr>
<tr class="separator:ga7a2db17db761047f9a4f32e57c9c21df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae951ed98bb3c1d1eb9deb37d6f1a0828"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#gae951ed98bb3c1d1eb9deb37d6f1a0828">magma_sstedx</a> (magma_range_t range, magma_int_t n, float vl, float vu, magma_int_t il, magma_int_t iu, float *d, float *e, float *Z, magma_int_t ldz, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magmaFloat_ptr dwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gae951ed98bb3c1d1eb9deb37d6f1a0828"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#gae951ed98bb3c1d1eb9deb37d6f1a0828">More...</a><br /></td></tr>
<tr class="separator:gae951ed98bb3c1d1eb9deb37d6f1a0828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343ee9238e83e14eae09e6461733278e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#ga343ee9238e83e14eae09e6461733278e">magma_sstedx_m</a> (magma_int_t ngpu, magma_range_t range, magma_int_t n, float vl, float vu, magma_int_t il, magma_int_t iu, float *d, float *e, float *Z, magma_int_t ldz, float *work, magma_int_t lwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga343ee9238e83e14eae09e6461733278e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga343ee9238e83e14eae09e6461733278e">More...</a><br /></td></tr>
<tr class="separator:ga343ee9238e83e14eae09e6461733278e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602e5ff0c13993676dc9a80871cd8f65"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#ga602e5ff0c13993676dc9a80871cd8f65">magma_zstedx</a> (magma_range_t range, magma_int_t n, double vl, double vu, magma_int_t il, magma_int_t iu, double *d, double *e, magmaDoubleComplex *Z, magma_int_t ldz, double *rwork, magma_int_t lrwork, magma_int_t *iwork, magma_int_t liwork, magmaDouble_ptr dwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga602e5ff0c13993676dc9a80871cd8f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga602e5ff0c13993676dc9a80871cd8f65">More...</a><br /></td></tr>
<tr class="separator:ga602e5ff0c13993676dc9a80871cd8f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be2d55ead100c9ca2bb299f4e7bb190"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__stedx.html#ga0be2d55ead100c9ca2bb299f4e7bb190">magma_zstedx_m</a> (magma_int_t ngpu, magma_range_t range, magma_int_t n, double vl, double vu, magma_int_t il, magma_int_t iu, double *d, double *e, magmaDoubleComplex *Z, magma_int_t ldz, double *rwork, magma_int_t lrwork, magma_int_t *iwork, magma_int_t liwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga0be2d55ead100c9ca2bb299f4e7bb190"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method.  <a href="#ga0be2d55ead100c9ca2bb299f4e7bb190">More...</a><br /></td></tr>
<tr class="separator:ga0be2d55ead100c9ca2bb299f4e7bb190"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac0b418257d462b5007c7b4f5d3b6173c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cstedx </td>
          <td>(</td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lrwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>REAL array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>REAL array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>COMPLEX array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>(workspace) REAL array, dimension (LRWORK) On exit, if INFO = 0, RWORK[0] returns the optimal LRWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lrwork</td><td>INTEGER The dimension of the array RWORK. LRWORK &gt;= 1 + 4*N + 2*N**2. Note that if N is less than or equal to the minimum divide size, usually 25, then LRWORK need only be max(1,2*(N-1)). <br />
 If LRWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= 3 + 5*N . Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dwork</td><td>(workspace) REAL array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="ga058fcc87790b6d51cf1f7d1cf32c5524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cstedx_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lrwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>REAL array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>REAL array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>COMPLEX array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>(workspace) REAL array, dimension (LRWORK) On exit, if INFO = 0, RWORK[0] returns the optimal LRWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lrwork</td><td>INTEGER The dimension of the array RWORK. LRWORK &gt;= 1 + 4*N + 2*N**2 . Note that if N is less than or equal to the minimum divide size, usually 25, then LRWORK need only be max(1,2*(N-1)). <br />
 If LRWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= 3 + 5*N . Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="ga894ce156db4fe17a0997135548f3db20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dstedx </td>
          <td>(</td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See DLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>DOUBLE PRECISION </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>DOUBLE PRECISION array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>DOUBLE PRECISION array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td>DOUBLE PRECISION array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If N &gt; 1 then LWORK &gt;= ( 1 + 4*N + N**2 ). Note that if N is less than or equal to the minimum divide size, usually 25, then LWORK need only be max(1,2*(N-1)). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= ( 3 + 5*N ). Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dwork</td><td>(workspace) DOUBLE PRECISION array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga7a2db17db761047f9a4f32e57c9c21df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dstedx_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See DLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>DOUBLE PRECISION </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>DOUBLE PRECISION array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>DOUBLE PRECISION array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td>DOUBLE PRECISION array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If N &gt; 1 then LWORK &gt;= ( 1 + 4*N + N**2 ). Note that if N is less than or equal to the minimum divide size, usually 25, then LWORK need only be max(1,2*(N-1)). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= ( 3 + 5*N ). Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="gae951ed98bb3c1d1eb9deb37d6f1a0828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sstedx </td>
          <td>(</td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>REAL array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>REAL array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td>REAL array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If N &gt; 1 then LWORK &gt;= ( 1 + 4*N + N**2 ). Note that if N is less than or equal to the minimum divide size, usually 25, then LWORK need only be max(1,2*(N-1)). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= ( 3 + 5*N ). Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dwork</td><td>(workspace) REAL array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga343ee9238e83e14eae09e6461733278e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sstedx_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSTEDX computes some eigenvalues and, optionally, eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See SLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>REAL array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>REAL array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td>REAL array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (LWORK) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If N &gt; 1 then LWORK &gt;= ( 1 + 4*N + N**2 ). Note that if N is less than or equal to the minimum divide size, usually 25, then LWORK need only be max(1,2*(N-1)). <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= ( 3 + 5*N ). Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the IWORK array, returns this value as the first entry of the IWORK array, and no error message related to LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA Modified by Francoise Tisseur, University of Tennessee. </p>

</div>
</div>
<a class="anchor" id="ga602e5ff0c13993676dc9a80871cd8f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zstedx </td>
          <td>(</td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lrwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See DLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>DOUBLE PRECISION </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>DOUBLE PRECISION array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>DOUBLE PRECISION array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>COMPLEX_16 array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>(workspace) DOUBLE PRECISION array, dimension (LRWORK) On exit, if INFO = 0, RWORK[0] returns the optimal LRWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lrwork</td><td>INTEGER The dimension of the array RWORK. LRWORK &gt;= 1 + 4*N + 2*N**2. Note that if N is less than or equal to the minimum divide size, usually 25, then LRWORK need only be max(1,2*(N-1)). <br />
 If LRWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= 3 + 5*N . Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dwork</td><td>(workspace) DOUBLE PRECISION array, dimension (3*N*N/2+3*N)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
<a class="anchor" id="ga0be2d55ead100c9ca2bb299f4e7bb190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zstedx_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lrwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>liwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZSTEDX computes some eigenvalues and eigenvectors of a symmetric tridiagonal matrix using the divide and conquer method. </p>
<p>This code makes very mild assumptions about floating point arithmetic. It will work on machines with a guard digit in add/subtract, or on those binary machines without guard digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2. It could conceivably fail on hexadecimal or decimal machines without guard digits, but we know of none. See DLAEX3 for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The dimension of the symmetric tridiagonal matrix. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>DOUBLE PRECISION </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>DOUBLE PRECISION array, dimension (N) On entry, the diagonal elements of the tridiagonal matrix. On exit, if INFO = 0, the eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e</td><td>DOUBLE PRECISION array, dimension (N-1) On entry, the subdiagonal elements of the tridiagonal matrix. On exit, E has been destroyed.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>COMPLEX_16 array, dimension (LDZ,N) On exit, if INFO = 0, Z contains the orthonormal eigenvectors of the symmetric tridiagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rwork</td><td>(workspace) DOUBLE PRECISION array, dimension (LRWORK) On exit, if INFO = 0, RWORK[0] returns the optimal LRWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lrwork</td><td>INTEGER The dimension of the array RWORK. LRWORK &gt;= 1 + 4*N + 2*N**2 . Note that if N is less than or equal to the minimum divide size, usually 25, then LRWORK need only be max(1,2*(N-1)). <br />
 If LRWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (MAX(1,LIWORK)) On exit, if INFO = 0, IWORK[0] returns the optimal LIWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">liwork</td><td>INTEGER The dimension of the array IWORK. LIWORK &gt;= 3 + 5*N . Note that if N is less than or equal to the minimum divide size, usually 25, then LIWORK need only be 1. <br />
 If LIWORK = -1, then a workspace query is assumed; the routine only calculates the optimal sizes of the WORK, RWORK and IWORK arrays, returns these values as the first entries of the WORK, RWORK and IWORK arrays, and no error message related to LWORK or LRWORK or LIWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit.</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value.</li>
<li>&gt; 0: The algorithm failed to compute an eigenvalue while working on the submatrix lying in rows and columns INFO/(N+1) through mod(INFO,N+1).</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Jeff Rutter, Computer Science Division, University of California at Berkeley, USA </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
