<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: sy/hegvx:  Solves using QR iteration (expert)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Routines</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__hegvx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sy/hegvx: Solves using QR iteration (expert)<div class="ingroups"><a class="el" href="group__dense.html">Dense linear algebra</a> &raquo; <a class="el" href="group__group__eigenvalue.html">Eigenvalues</a> &raquo; <a class="el" href="group__group__hegv.html">Generalized Symmetric/Hermitian eigenvalues</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6516dd2c3a5c299c1b2f4381d5cf3eb3"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__hegvx.html#ga6516dd2c3a5c299c1b2f4381d5cf3eb3">magma_chegvx</a> (magma_int_t itype, magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *B, magma_int_t ldb, float vl, float vu, magma_int_t il, magma_int_t iu, float abstol, magma_int_t *m, float *w, magmaFloatComplex *Z, magma_int_t ldz, magmaFloatComplex *work, magma_int_t lwork, float *rwork, magma_int_t *iwork, magma_int_t *ifail, magma_int_t *info)</td></tr>
<tr class="memdesc:ga6516dd2c3a5c299c1b2f4381d5cf3eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CHEGVX computes selected eigenvalues, and optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.  <a href="#ga6516dd2c3a5c299c1b2f4381d5cf3eb3">More...</a><br /></td></tr>
<tr class="separator:ga6516dd2c3a5c299c1b2f4381d5cf3eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf417948c6ebc60a219f68041e6eb40"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__hegvx.html#gabcf417948c6ebc60a219f68041e6eb40">magma_zhegvx</a> (magma_int_t itype, magma_vec_t jobz, magma_range_t range, magma_uplo_t uplo, magma_int_t n, magmaDoubleComplex *A, magma_int_t lda, magmaDoubleComplex *B, magma_int_t ldb, double vl, double vu, magma_int_t il, magma_int_t iu, double abstol, magma_int_t *m, double *w, magmaDoubleComplex *Z, magma_int_t ldz, magmaDoubleComplex *work, magma_int_t lwork, double *rwork, magma_int_t *iwork, magma_int_t *ifail, magma_int_t *info)</td></tr>
<tr class="memdesc:gabcf417948c6ebc60a219f68041e6eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZHEGVX computes selected eigenvalues, and optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x.  <a href="#gabcf417948c6ebc60a219f68041e6eb40">More...</a><br /></td></tr>
<tr class="separator:gabcf417948c6ebc60a219f68041e6eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6516dd2c3a5c299c1b2f4381d5cf3eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_chegvx </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ifail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CHEGVX computes selected eigenvalues, and optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. </p>
<p>Here A and B are assumed to be Hermitian and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itype</td><td>INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangles of A and B are stored;</li>
<li>= MagmaLower: Lower triangles of A and B are stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrices A and B. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX array, dimension (LDA, N) On entry, the Hermitian matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. <br />
 On exit, the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>COMPLEX array, dimension (LDB, N) On entry, the Hermitian matrix B. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of B contains the upper triangular part of the matrix B. If UPLO = MagmaLower, the leading N-by-N lower triangular part of B contains the lower triangular part of the matrix B. <br />
 On exit, if INFO &lt;= N, the part of B containing the matrix is overwritten by the triangular factor U or L from the Cholesky factorization B = U**H*U or B = L*L**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>REAL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>REAL If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abstol</td><td>REAL The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to <br />
 ABSTOL + EPS * max( |a|,|b| ), <br />
 where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form. <br />
 Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*SLAMCH('S'), not zero. If this routine returns with INFO &gt; 0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*SLAMCH('S').</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>REAL array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>COMPLEX array, dimension (LDZ, max(1,M)) If JOBZ = MagmaNoVec, then Z is not referenced. If JOBZ = MagmaVec, then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I. <br />
 If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = MagmaRangeV, the exact value of M is not known in advance and an upper bound must be used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = MagmaVec, LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. LWORK &gt;= max(1,2*N). For optimal efficiency, LWORK &gt;= (NB+1)*N, where NB is the blocksize for CHETRD returned by ILAENV. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rwork</td><td>(workspace) REAL array, dimension (7*N)</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (5*N)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifail</td><td>INTEGER array, dimension (N) If JOBZ = MagmaVec, then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = MagmaNoVec, then IFAIL is not referenced.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: CPOTRF or CHEEVX returned an error code: &lt;= N: if INFO = i, CHEEVX failed to converge; i eigenvectors failed to converge. Their indices are stored in array IFAIL. &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>

</div>
</div>
<a class="anchor" id="gabcf417948c6ebc60a219f68041e6eb40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zhegvx </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>itype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_vec_t&#160;</td>
          <td class="paramname"><em>jobz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_range_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_uplo_t&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>iu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abstol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>ifail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZHEGVX computes selected eigenvalues, and optionally, eigenvectors of a complex generalized Hermitian-definite eigenproblem, of the form A*x=(lambda)*B*x, A*Bx=(lambda)*x, or B*A*x=(lambda)*x. </p>
<p>Here A and B are assumed to be Hermitian and B is also positive definite. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itype</td><td>INTEGER Specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x = (lambda)*x = 3: B*A*x = (lambda)*x</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jobz</td><td>magma_vec_t<ul>
<li>= MagmaNoVec: Compute eigenvalues only;</li>
<li>= MagmaVec: Compute eigenvalues and eigenvectors.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>magma_range_t<ul>
<li>= MagmaRangeAll: all eigenvalues will be found.</li>
<li>= MagmaRangeV: all eigenvalues in the half-open interval (VL,VU] will be found.</li>
<li>= MagmaRangeI: the IL-th through IU-th eigenvalues will be found.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uplo</td><td>magma_uplo_t<ul>
<li>= MagmaUpper: Upper triangles of A and B are stored;</li>
<li>= MagmaLower: Lower triangles of A and B are stored.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The order of the matrices A and B. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>COMPLEX_16 array, dimension (LDA, N) On entry, the Hermitian matrix A. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of A contains the upper triangular part of the matrix A. If UPLO = MagmaLower, the leading N-by-N lower triangular part of A contains the lower triangular part of the matrix A. <br />
 On exit, the lower triangle (if UPLO=MagmaLower) or the upper triangle (if UPLO=MagmaUpper) of A, including the diagonal, is destroyed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td>COMPLEX_16 array, dimension (LDB, N) On entry, the Hermitian matrix B. If UPLO = MagmaUpper, the leading N-by-N upper triangular part of B contains the upper triangular part of the matrix B. If UPLO = MagmaLower, the leading N-by-N lower triangular part of B contains the lower triangular part of the matrix B. <br />
 On exit, if INFO &lt;= N, the part of B containing the matrix is overwritten by the triangular factor U or L from the Cholesky factorization B = U**H*U or B = L*L**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldb</td><td>INTEGER The leading dimension of the array B. LDB &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vl</td><td>DOUBLE PRECISION </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vu</td><td>DOUBLE PRECISION If RANGE=MagmaRangeV, the lower and upper bounds of the interval to be searched for eigenvalues. VL &lt; VU. Not referenced if RANGE = MagmaRangeAll or MagmaRangeI.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>INTEGER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iu</td><td>INTEGER If RANGE=MagmaRangeI, the indices (in ascending order) of the smallest and largest eigenvalues to be returned. 1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0; IL = 1 and IU = 0 if N = 0. Not referenced if RANGE = MagmaRangeAll or MagmaRangeV.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abstol</td><td>DOUBLE PRECISION The absolute error tolerance for the eigenvalues. An approximate eigenvalue is accepted as converged when it is determined to lie in an interval [a,b] of width less than or equal to <br />
 ABSTOL + EPS * max( |a|,|b| ), <br />
 where EPS is the machine precision. If ABSTOL is less than or equal to zero, then EPS*|T| will be used in its place, where |T| is the 1-norm of the tridiagonal matrix obtained by reducing A to tridiagonal form. <br />
 Eigenvalues will be computed most accurately when ABSTOL is set to twice the underflow threshold 2*DLAMCH('S'), not zero. If this routine returns with INFO &gt; 0, indicating that some eigenvectors did not converge, try setting ABSTOL to 2*DLAMCH('S').</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>INTEGER The total number of eigenvalues found. 0 &lt;= M &lt;= N. If RANGE = MagmaRangeAll, M = N, and if RANGE = MagmaRangeI, M = IU-IL+1.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>DOUBLE PRECISION array, dimension (N) The first M elements contain the selected eigenvalues in ascending order.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>COMPLEX_16 array, dimension (LDZ, max(1,M)) If JOBZ = MagmaNoVec, then Z is not referenced. If JOBZ = MagmaVec, then if INFO = 0, the first M columns of Z contain the orthonormal eigenvectors of the matrix A corresponding to the selected eigenvalues, with the i-th column of Z holding the eigenvector associated with W(i). The eigenvectors are normalized as follows: if ITYPE = 1 or 2, Z**T*B*Z = I; if ITYPE = 3, Z**T*inv(B)*Z = I. <br />
 If an eigenvector fails to converge, then that column of Z contains the latest approximation to the eigenvector, and the index of the eigenvector is returned in IFAIL. Note: the user must ensure that at least max(1,M) columns are supplied in the array Z; if RANGE = MagmaRangeV, the exact value of M is not known in advance and an upper bound must be used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldz</td><td>INTEGER The leading dimension of the array Z. LDZ &gt;= 1, and if JOBZ = MagmaVec, LDZ &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX_16 array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The length of the array WORK. LWORK &gt;= max(1,2*N). For optimal efficiency, LWORK &gt;= (NB+1)*N, where NB is the blocksize for ZHETRD returned by ILAENV. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rwork</td><td>(workspace) DOUBLE PRECISION array, dimension (7*N)</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iwork</td><td>(workspace) INTEGER array, dimension (5*N)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifail</td><td>INTEGER array, dimension (N) If JOBZ = MagmaVec, then if INFO = 0, the first M elements of IFAIL are zero. If INFO &gt; 0, then IFAIL contains the indices of the eigenvectors that failed to converge. If JOBZ = MagmaNoVec, then IFAIL is not referenced.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value</li>
<li>&gt; 0: ZPOTRF or ZHEEVX returned an error code: &lt;= N: if INFO = i, ZHEEVX failed to converge; i eigenvectors failed to converge. Their indices are stored in array IFAIL. &gt; N: if INFO = N + i, for 1 &lt;= i &lt;= N, then the leading minor of order i of B is not positive definite. The factorization of B could not be completed and no eigenvalues or eigenvectors were computed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Further Details </h2>
<p>Based on contributions by Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
