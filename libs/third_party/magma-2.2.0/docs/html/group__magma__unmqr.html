<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: or/unmqr: Multiply by Q from QR factorization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Routines</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__unmqr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">or/unmqr: Multiply by Q from QR factorization<div class="ingroups"><a class="el" href="group__dense.html">Dense linear algebra</a> &raquo; <a class="el" href="group__group__orthogonal.html">Orthogonal/unitary factorizations</a> &raquo; <a class="el" href="group__group__qr.html">QR factorization</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab71088b3e710272db4944b8303c1f190"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gab71088b3e710272db4944b8303c1f190">magma_cunmqr</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *C, magma_int_t ldc, magmaFloatComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gab71088b3e710272db4944b8303c1f190"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR overwrites the general complex M-by-N matrix C with.  <a href="#gab71088b3e710272db4944b8303c1f190">More...</a><br /></td></tr>
<tr class="separator:gab71088b3e710272db4944b8303c1f190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3ca82d7fe0416112733bfa25cd21c1"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga2b3ca82d7fe0416112733bfa25cd21c1">magma_cunmqr2_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex_ptr dA, magma_int_t ldda, magmaFloatComplex *tau, magmaFloatComplex_ptr dC, magma_int_t lddc, const magmaFloatComplex *wA, magma_int_t ldwa, magma_int_t *info)</td></tr>
<tr class="memdesc:ga2b3ca82d7fe0416112733bfa25cd21c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR overwrites the general complex M-by-N matrix C with.  <a href="#ga2b3ca82d7fe0416112733bfa25cd21c1">More...</a><br /></td></tr>
<tr class="separator:ga2b3ca82d7fe0416112733bfa25cd21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1158f1a119ddcaba33d1a672b096e3d3"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga1158f1a119ddcaba33d1a672b096e3d3">magma_cunmqr_2stage_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex_ptr dA, magma_int_t ldda, magmaFloatComplex_ptr dC, magma_int_t lddc, magmaFloatComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga1158f1a119ddcaba33d1a672b096e3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR_GPU overwrites the general complex M-by-N matrix C with.  <a href="#ga1158f1a119ddcaba33d1a672b096e3d3">More...</a><br /></td></tr>
<tr class="separator:ga1158f1a119ddcaba33d1a672b096e3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae144558c91b463b428740f3f9dc91bf6"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gae144558c91b463b428740f3f9dc91bf6">magma_cunmqr_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex_const_ptr dA, magma_int_t ldda, magmaFloatComplex const *tau, magmaFloatComplex_ptr dC, magma_int_t lddc, magmaFloatComplex *hwork, magma_int_t lwork, magmaFloatComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:gae144558c91b463b428740f3f9dc91bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR_GPU overwrites the general complex M-by-N matrix C with.  <a href="#gae144558c91b463b428740f3f9dc91bf6">More...</a><br /></td></tr>
<tr class="separator:gae144558c91b463b428740f3f9dc91bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff16342d839dbfe0fe82e22523c57c2"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga9ff16342d839dbfe0fe82e22523c57c2">magma_cunmqr_m</a> (magma_int_t ngpu, magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *C, magma_int_t ldc, magmaFloatComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga9ff16342d839dbfe0fe82e22523c57c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNMQR overwrites the general complex M-by-N matrix C with.  <a href="#ga9ff16342d839dbfe0fe82e22523c57c2">More...</a><br /></td></tr>
<tr class="separator:ga9ff16342d839dbfe0fe82e22523c57c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c875b90a1663dcc8763ba85e284168"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga87c875b90a1663dcc8763ba85e284168">magma_dormqr</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, double *A, magma_int_t lda, double *tau, double *C, magma_int_t ldc, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga87c875b90a1663dcc8763ba85e284168"><td class="mdescLeft">&#160;</td><td class="mdescRight">DORMQR overwrites the general real M-by-N matrix C with.  <a href="#ga87c875b90a1663dcc8763ba85e284168">More...</a><br /></td></tr>
<tr class="separator:ga87c875b90a1663dcc8763ba85e284168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3af637b21d3af61bffcb48150b9664"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gabc3af637b21d3af61bffcb48150b9664">magma_dormqr2_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDouble_ptr dA, magma_int_t ldda, double *tau, magmaDouble_ptr dC, magma_int_t lddc, const double *wA, magma_int_t ldwa, magma_int_t *info)</td></tr>
<tr class="memdesc:gabc3af637b21d3af61bffcb48150b9664"><td class="mdescLeft">&#160;</td><td class="mdescRight">DORMQR overwrites the general real M-by-N matrix C with.  <a href="#gabc3af637b21d3af61bffcb48150b9664">More...</a><br /></td></tr>
<tr class="separator:gabc3af637b21d3af61bffcb48150b9664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bc2071c66d7199945ffd97d5ca7835"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga94bc2071c66d7199945ffd97d5ca7835">magma_dormqr_2stage_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDouble_ptr dA, magma_int_t ldda, magmaDouble_ptr dC, magma_int_t lddc, magmaDouble_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga94bc2071c66d7199945ffd97d5ca7835"><td class="mdescLeft">&#160;</td><td class="mdescRight">DORMQR_GPU overwrites the general real M-by-N matrix C with.  <a href="#ga94bc2071c66d7199945ffd97d5ca7835">More...</a><br /></td></tr>
<tr class="separator:ga94bc2071c66d7199945ffd97d5ca7835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e3140105e61e0d2801181e132e7317"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gaf4e3140105e61e0d2801181e132e7317">magma_dormqr_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDouble_const_ptr dA, magma_int_t ldda, double const *tau, magmaDouble_ptr dC, magma_int_t lddc, double *hwork, magma_int_t lwork, magmaDouble_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:gaf4e3140105e61e0d2801181e132e7317"><td class="mdescLeft">&#160;</td><td class="mdescRight">DORMQR_GPU overwrites the general real M-by-N matrix C with.  <a href="#gaf4e3140105e61e0d2801181e132e7317">More...</a><br /></td></tr>
<tr class="separator:gaf4e3140105e61e0d2801181e132e7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab0c0e7c4bb84fc2e0a2e3572998cf8"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gaeab0c0e7c4bb84fc2e0a2e3572998cf8">magma_dormqr_m</a> (magma_int_t ngpu, magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, double *A, magma_int_t lda, double *tau, double *C, magma_int_t ldc, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaeab0c0e7c4bb84fc2e0a2e3572998cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">DORMQR overwrites the general real M-by-N matrix C with.  <a href="#gaeab0c0e7c4bb84fc2e0a2e3572998cf8">More...</a><br /></td></tr>
<tr class="separator:gaeab0c0e7c4bb84fc2e0a2e3572998cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f5c030789f0e1645b75efcb8e37096"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gac0f5c030789f0e1645b75efcb8e37096">magma_sormqr</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, float *A, magma_int_t lda, float *tau, float *C, magma_int_t ldc, float *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gac0f5c030789f0e1645b75efcb8e37096"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQR overwrites the general real M-by-N matrix C with.  <a href="#gac0f5c030789f0e1645b75efcb8e37096">More...</a><br /></td></tr>
<tr class="separator:gac0f5c030789f0e1645b75efcb8e37096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ab032dc9c089e54b1b9aa1779f7961"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gaf0ab032dc9c089e54b1b9aa1779f7961">magma_sormqr2_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloat_ptr dA, magma_int_t ldda, float *tau, magmaFloat_ptr dC, magma_int_t lddc, const float *wA, magma_int_t ldwa, magma_int_t *info)</td></tr>
<tr class="memdesc:gaf0ab032dc9c089e54b1b9aa1779f7961"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQR overwrites the general real M-by-N matrix C with.  <a href="#gaf0ab032dc9c089e54b1b9aa1779f7961">More...</a><br /></td></tr>
<tr class="separator:gaf0ab032dc9c089e54b1b9aa1779f7961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083aeff2291245a3379e155573dc98a5"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga083aeff2291245a3379e155573dc98a5">magma_sormqr_2stage_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloat_ptr dA, magma_int_t ldda, magmaFloat_ptr dC, magma_int_t lddc, magmaFloat_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga083aeff2291245a3379e155573dc98a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQR_GPU overwrites the general real M-by-N matrix C with.  <a href="#ga083aeff2291245a3379e155573dc98a5">More...</a><br /></td></tr>
<tr class="separator:ga083aeff2291245a3379e155573dc98a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7c61a1b509da9b09736163410525a8"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga4e7c61a1b509da9b09736163410525a8">magma_sormqr_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloat_const_ptr dA, magma_int_t ldda, float const *tau, magmaFloat_ptr dC, magma_int_t lddc, float *hwork, magma_int_t lwork, magmaFloat_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga4e7c61a1b509da9b09736163410525a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQR_GPU overwrites the general real M-by-N matrix C with.  <a href="#ga4e7c61a1b509da9b09736163410525a8">More...</a><br /></td></tr>
<tr class="separator:ga4e7c61a1b509da9b09736163410525a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dbbb86d1e21d333639e8d3a7755f996"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga2dbbb86d1e21d333639e8d3a7755f996">magma_sormqr_m</a> (magma_int_t ngpu, magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, float *A, magma_int_t lda, float *tau, float *C, magma_int_t ldc, float *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga2dbbb86d1e21d333639e8d3a7755f996"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORMQR overwrites the general real M-by-N matrix C with.  <a href="#ga2dbbb86d1e21d333639e8d3a7755f996">More...</a><br /></td></tr>
<tr class="separator:ga2dbbb86d1e21d333639e8d3a7755f996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04caefefcecc9958e5a515584f09cf95"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga04caefefcecc9958e5a515584f09cf95">magma_zunmqr</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDoubleComplex *A, magma_int_t lda, magmaDoubleComplex *tau, magmaDoubleComplex *C, magma_int_t ldc, magmaDoubleComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga04caefefcecc9958e5a515584f09cf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZUNMQR overwrites the general complex M-by-N matrix C with.  <a href="#ga04caefefcecc9958e5a515584f09cf95">More...</a><br /></td></tr>
<tr class="separator:ga04caefefcecc9958e5a515584f09cf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3219b09f44b990599efc32cbf986cef0"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga3219b09f44b990599efc32cbf986cef0">magma_zunmqr2_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDoubleComplex_ptr dA, magma_int_t ldda, magmaDoubleComplex *tau, magmaDoubleComplex_ptr dC, magma_int_t lddc, const magmaDoubleComplex *wA, magma_int_t ldwa, magma_int_t *info)</td></tr>
<tr class="memdesc:ga3219b09f44b990599efc32cbf986cef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZUNMQR overwrites the general complex M-by-N matrix C with.  <a href="#ga3219b09f44b990599efc32cbf986cef0">More...</a><br /></td></tr>
<tr class="separator:ga3219b09f44b990599efc32cbf986cef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9a04dd4fb216635b0c8727bf34480b"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#gafb9a04dd4fb216635b0c8727bf34480b">magma_zunmqr_2stage_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDoubleComplex_ptr dA, magma_int_t ldda, magmaDoubleComplex_ptr dC, magma_int_t lddc, magmaDoubleComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:gafb9a04dd4fb216635b0c8727bf34480b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZUNMQR_GPU overwrites the general complex M-by-N matrix C with.  <a href="#gafb9a04dd4fb216635b0c8727bf34480b">More...</a><br /></td></tr>
<tr class="separator:gafb9a04dd4fb216635b0c8727bf34480b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga129a01a7caecb681c244e484435deac5"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga129a01a7caecb681c244e484435deac5">magma_zunmqr_gpu</a> (magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDoubleComplex_const_ptr dA, magma_int_t ldda, magmaDoubleComplex const *tau, magmaDoubleComplex_ptr dC, magma_int_t lddc, magmaDoubleComplex *hwork, magma_int_t lwork, magmaDoubleComplex_ptr dT, magma_int_t nb, magma_int_t *info)</td></tr>
<tr class="memdesc:ga129a01a7caecb681c244e484435deac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZUNMQR_GPU overwrites the general complex M-by-N matrix C with.  <a href="#ga129a01a7caecb681c244e484435deac5">More...</a><br /></td></tr>
<tr class="separator:ga129a01a7caecb681c244e484435deac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76cdee4665c9594ead67e719edc2db73"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__unmqr.html#ga76cdee4665c9594ead67e719edc2db73">magma_zunmqr_m</a> (magma_int_t ngpu, magma_side_t side, magma_trans_t trans, magma_int_t m, magma_int_t n, magma_int_t k, magmaDoubleComplex *A, magma_int_t lda, magmaDoubleComplex *tau, magmaDoubleComplex *C, magma_int_t ldc, magmaDoubleComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga76cdee4665c9594ead67e719edc2db73"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZUNMQR overwrites the general complex M-by-N matrix C with.  <a href="#ga76cdee4665c9594ead67e719edc2db73">More...</a><br /></td></tr>
<tr class="separator:ga76cdee4665c9594ead67e719edc2db73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab71088b3e710272db4944b8303c1f190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunmqr </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNMQR overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                          SIDE = MagmaLeft   SIDE = MagmaRight
TRANS = MagmaNoTrans:     Q * C              C * Q
TRANS = Magma_ConjTrans:  Q**H * C           C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by CGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>COMPLEX array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF in the first k columns of its array argument A. A is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>COMPLEX array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance if SIDE = MagmaLeft, LWORK &gt;= N*NB; if SIDE = MagmaRight, LWORK &gt;= M*NB, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b3ca82d7fe0416112733bfa25cd21c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunmqr2_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>wA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldwa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNMQR overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by CGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>COMPLEX array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF in the first k columns of its array argument dA. The diagonal and the upper part are destroyed, the reflectors are not modified.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array dC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wA</td><td>COMPLEX array, dimension (LDWA,M) if SIDE = MagmaLeft (LDWA,N) if SIDE = MagmaRight The vectors which define the elementary reflectors, as returned by CHETRD_GPU. (A copy of the upper or lower part of dA, on the host.)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldwa</td><td>INTEGER The leading dimension of the array wA. If SIDE = MagmaLeft, LDWA &gt;= max(1,M); if SIDE = MagmaRight, LDWA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1158f1a119ddcaba33d1a672b096e3d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunmqr_2stage_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNMQR_GPU overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by CGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>COMPLEX array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF in the first k columns of its array argument DA. DA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>COMPLEX array on the GPU that is the output (the 9th argument) of magma_cgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_cgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae144558c91b463b428740f3f9dc91bf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunmqr_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_const_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex const *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>hwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNMQR_GPU overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by CGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>COMPLEX array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF in the first k columns of its array argument dA. dA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hwork</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) <br />
 Currently, cgetrs_gpu assumes that on exit, hwork contains the last block of A and C. This will change and <em>should not be relied on</em>!</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array HWORK. LWORK &gt;= (M-K+NB)*(N+NB) + N*NB if SIDE = MagmaLeft, and LWORK &gt;= (N-K+NB)*(M+NB) + M*NB if SIDE = MagmaRight, where NB is the given blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the HWORK array, returns this value as the first entry of the HWORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dT</td><td>COMPLEX array on the GPU that is the output (the 9th argument) of magma_cgeqrf_gpu. Part used as workspace.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_cgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ff16342d839dbfe0fe82e22523c57c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cunmqr_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNMQR overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                            SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:       Q * C               C * Q
TRANS = Magma_ConjTrans:    Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by CGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>COMPLEX array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by CGEQRF in the first k columns of its array argument A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by CGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>COMPLEX array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = MagmaLeft, and LWORK &gt;= M*NB if SIDE = MagmaRight, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87c875b90a1663dcc8763ba85e284168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dormqr </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DORMQR overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                          SIDE = MagmaLeft   SIDE = MagmaRight
TRANS = MagmaNoTrans:     Q * C              C * Q
TRANS = MagmaTrans:  Q**H * C           C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>DOUBLE PRECISION array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument A. A is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance if SIDE = MagmaLeft, LWORK &gt;= N*NB; if SIDE = MagmaRight, LWORK &gt;= M*NB, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc3af637b21d3af61bffcb48150b9664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dormqr2_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>wA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldwa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DORMQR overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = MagmaTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>DOUBLE PRECISION array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument dA. The diagonal and the upper part are destroyed, the reflectors are not modified.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>DOUBLE PRECISION array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array dC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wA</td><td>DOUBLE PRECISION array, dimension (LDWA,M) if SIDE = MagmaLeft (LDWA,N) if SIDE = MagmaRight The vectors which define the elementary reflectors, as returned by DSYTRD_GPU. (A copy of the upper or lower part of dA, on the host.)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldwa</td><td>INTEGER The leading dimension of the array wA. If SIDE = MagmaLeft, LDWA &gt;= max(1,M); if SIDE = MagmaRight, LDWA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94bc2071c66d7199945ffd97d5ca7835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dormqr_2stage_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DORMQR_GPU overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = MagmaTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>DOUBLE PRECISION array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument DA. DA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>DOUBLE PRECISION array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>DOUBLE PRECISION array on the GPU that is the output (the 9th argument) of magma_dgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_dgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4e3140105e61e0d2801181e132e7317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dormqr_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_const_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>hwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDouble_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DORMQR_GPU overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = MagmaTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>DOUBLE PRECISION array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument dA. dA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>DOUBLE PRECISION array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hwork</td><td>(workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) <br />
 Currently, dgetrs_gpu assumes that on exit, hwork contains the last block of A and C. This will change and <em>should not be relied on</em>!</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array HWORK. LWORK &gt;= (M-K+NB)*(N+NB) + N*NB if SIDE = MagmaLeft, and LWORK &gt;= (N-K+NB)*(M+NB) + M*NB if SIDE = MagmaRight, where NB is the given blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the HWORK array, returns this value as the first entry of the HWORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dT</td><td>DOUBLE PRECISION array on the GPU that is the output (the 9th argument) of magma_dgeqrf_gpu. Part used as workspace.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_dgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeab0c0e7c4bb84fc2e0a2e3572998cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dormqr_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DORMQR overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                            SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:       Q * C               C * Q
TRANS = MagmaTrans:    Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by DGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>DOUBLE PRECISION array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by DGEQRF in the first k columns of its array argument A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>DOUBLE PRECISION array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by DGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>DOUBLE PRECISION array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = MagmaLeft, and LWORK &gt;= M*NB if SIDE = MagmaRight, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac0f5c030789f0e1645b75efcb8e37096"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sormqr </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SORMQR overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                          SIDE = MagmaLeft   SIDE = MagmaRight
TRANS = MagmaNoTrans:     Q * C              C * Q
TRANS = MagmaTrans:  Q**H * C           C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by SGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>REAL array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by SGEQRF in the first k columns of its array argument A. A is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>REAL array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by SGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>REAL array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance if SIDE = MagmaLeft, LWORK &gt;= N*NB; if SIDE = MagmaRight, LWORK &gt;= M*NB, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0ab032dc9c089e54b1b9aa1779f7961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sormqr2_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>wA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldwa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SORMQR overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = MagmaTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by SGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>REAL array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by SGEQRF in the first k columns of its array argument dA. The diagonal and the upper part are destroyed, the reflectors are not modified.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>REAL array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by SGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>REAL array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array dC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wA</td><td>REAL array, dimension (LDWA,M) if SIDE = MagmaLeft (LDWA,N) if SIDE = MagmaRight The vectors which define the elementary reflectors, as returned by SSYTRD_GPU. (A copy of the upper or lower part of dA, on the host.)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldwa</td><td>INTEGER The leading dimension of the array wA. If SIDE = MagmaLeft, LDWA &gt;= max(1,M); if SIDE = MagmaRight, LDWA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga083aeff2291245a3379e155573dc98a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sormqr_2stage_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SORMQR_GPU overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = MagmaTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by SGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>REAL array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by SGEQRF in the first k columns of its array argument DA. DA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>REAL array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>REAL array on the GPU that is the output (the 9th argument) of magma_sgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_sgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e7c61a1b509da9b09736163410525a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sormqr_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_const_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloat_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SORMQR_GPU overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = MagmaTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by SGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>REAL array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by SGEQRF in the first k columns of its array argument dA. dA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>REAL array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by SGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>REAL array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hwork</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) <br />
 Currently, sgetrs_gpu assumes that on exit, hwork contains the last block of A and C. This will change and <em>should not be relied on</em>!</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array HWORK. LWORK &gt;= (M-K+NB)*(N+NB) + N*NB if SIDE = MagmaLeft, and LWORK &gt;= (N-K+NB)*(M+NB) + M*NB if SIDE = MagmaRight, where NB is the given blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the HWORK array, returns this value as the first entry of the HWORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dT</td><td>REAL array on the GPU that is the output (the 9th argument) of magma_sgeqrf_gpu. Part used as workspace.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_sgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2dbbb86d1e21d333639e8d3a7755f996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sormqr_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SORMQR overwrites the general real M-by-N matrix C with. </p>
<pre class="fragment">                            SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:       Q * C               C * Q
TRANS = MagmaTrans:    Q**H * C            C * Q**H
</pre><p>where Q is a real orthogonal matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by SGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= MagmaTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>REAL array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by SGEQRF in the first k columns of its array argument A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>REAL array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by SGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>REAL array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) REAL array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = MagmaLeft, and LWORK &gt;= M*NB if SIDE = MagmaRight, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04caefefcecc9958e5a515584f09cf95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zunmqr </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZUNMQR overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                          SIDE = MagmaLeft   SIDE = MagmaRight
TRANS = MagmaNoTrans:     Q * C              C * Q
TRANS = Magma_ConjTrans:  Q**H * C           C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by ZGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>COMPLEX_16 array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by ZGEQRF in the first k columns of its array argument A. A is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX_16 array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by ZGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>COMPLEX_16 array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX_16 array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance if SIDE = MagmaLeft, LWORK &gt;= N*NB; if SIDE = MagmaRight, LWORK &gt;= M*NB, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3219b09f44b990599efc32cbf986cef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zunmqr2_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>wA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldwa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZUNMQR overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by ZGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dA</td><td>COMPLEX_16 array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by ZGEQRF in the first k columns of its array argument dA. The diagonal and the upper part are destroyed, the reflectors are not modified.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX_16 array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by ZGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX_16 array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array dC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wA</td><td>COMPLEX_16 array, dimension (LDWA,M) if SIDE = MagmaLeft (LDWA,N) if SIDE = MagmaRight The vectors which define the elementary reflectors, as returned by ZHETRD_GPU. (A copy of the upper or lower part of dA, on the host.)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldwa</td><td>INTEGER The leading dimension of the array wA. If SIDE = MagmaLeft, LDWA &gt;= max(1,M); if SIDE = MagmaRight, LDWA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb9a04dd4fb216635b0c8727bf34480b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zunmqr_2stage_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZUNMQR_GPU overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">Q = H(1) H(2) . . . H(k)
</pre><p>as returned by ZGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>COMPLEX_16 array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by ZGEQRF in the first k columns of its array argument DA. DA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array DA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX_16 array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H * C or C * Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>COMPLEX_16 array on the GPU that is the output (the 9th argument) of magma_zgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_zgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga129a01a7caecb681c244e484435deac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zunmqr_gpu </td>
          <td>(</td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_const_ptr&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex const *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lddc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>hwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex_ptr&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZUNMQR_GPU overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                           SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:      Q * C               C * Q
TRANS = Magma_ConjTrans:   Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by ZGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>COMPLEX_16 array on the GPU, dimension (LDDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by ZGEQRF in the first k columns of its array argument dA. dA is modified by the routine but restored on exit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldda</td><td>INTEGER The leading dimension of the array dA. If SIDE = MagmaLeft, LDDA &gt;= max(1,M); if SIDE = MagmaRight, LDDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX_16 array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by ZGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dC</td><td>COMPLEX_16 array on the GPU, dimension (LDDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by (Q*C) or (Q**H * C) or (C * Q**H) or (C*Q).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lddc</td><td>INTEGER The leading dimension of the array DC. LDDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hwork</td><td>(workspace) COMPLEX_16 array, dimension (MAX(1,LWORK)) <br />
 Currently, zgetrs_gpu assumes that on exit, hwork contains the last block of A and C. This will change and <em>should not be relied on</em>!</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array HWORK. LWORK &gt;= (M-K+NB)*(N+NB) + N*NB if SIDE = MagmaLeft, and LWORK &gt;= (N-K+NB)*(M+NB) + M*NB if SIDE = MagmaRight, where NB is the given blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the HWORK array, returns this value as the first entry of the HWORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dT</td><td>COMPLEX_16 array on the GPU that is the output (the 9th argument) of magma_zgeqrf_gpu. Part used as workspace.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb</td><td>INTEGER This is the blocking size that was used in pre-computing DT, e.g., the blocking size used in magma_zgeqrf_gpu.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga76cdee4665c9594ead67e719edc2db73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zunmqr_m </td>
          <td>(</td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ngpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_side_t&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_trans_t&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZUNMQR overwrites the general complex M-by-N matrix C with. </p>
<pre class="fragment">                            SIDE = MagmaLeft    SIDE = MagmaRight
TRANS = MagmaNoTrans:       Q * C               C * Q
TRANS = Magma_ConjTrans:    Q**H * C            C * Q**H
</pre><p>where Q is a complex unitary matrix defined as the product of k elementary reflectors </p><pre class="fragment">  Q = H(1) H(2) . . . H(k)
</pre><p>as returned by ZGEQRF. Q is of order M if SIDE = MagmaLeft and of order N if SIDE = MagmaRight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ngpu</td><td>INTEGER Number of GPUs to use. ngpu &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>magma_side_t<ul>
<li>= MagmaLeft: apply Q or Q**H from the Left;</li>
<li>= MagmaRight: apply Q or Q**H from the Right.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>magma_trans_t<ul>
<li>= MagmaNoTrans: No transpose, apply Q;</li>
<li>= Magma_ConjTrans: Conjugate transpose, apply Q**H.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER The number of rows of the matrix C. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER The number of columns of the matrix C. N &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>INTEGER The number of elementary reflectors whose product defines the matrix Q. If SIDE = MagmaLeft, M &gt;= K &gt;= 0; if SIDE = MagmaRight, N &gt;= K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>COMPLEX_16 array, dimension (LDA,K) The i-th column must contain the vector which defines the elementary reflector H(i), for i = 1,2,...,k, as returned by ZGEQRF in the first k columns of its array argument A.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>INTEGER The leading dimension of the array A. If SIDE = MagmaLeft, LDA &gt;= max(1,M); if SIDE = MagmaRight, LDA &gt;= max(1,N).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>COMPLEX_16 array, dimension (K) TAU(i) must contain the scalar factor of the elementary reflector H(i), as returned by ZGEQRF.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">C</td><td>COMPLEX_16 array, dimension (LDC,N) On entry, the M-by-N matrix C. On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ldc</td><td>INTEGER The leading dimension of the array C. LDC &gt;= max(1,M).</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>(workspace) COMPLEX_16 array, dimension (MAX(1,LWORK)) On exit, if INFO = 0, WORK[0] returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>INTEGER The dimension of the array WORK. If SIDE = MagmaLeft, LWORK &gt;= max(1,N); if SIDE = MagmaRight, LWORK &gt;= max(1,M). For optimum performance LWORK &gt;= N*NB if SIDE = MagmaLeft, and LWORK &gt;= M*NB if SIDE = MagmaRight, where NB is the optimal blocksize. <br />
 If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>INTEGER<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
