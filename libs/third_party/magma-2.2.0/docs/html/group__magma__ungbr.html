<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MAGMA: or/ungbr: Generate    Q or P from bidiagonal reduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAGMA
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Routines</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__magma__ungbr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">or/ungbr: Generate Q or P from bidiagonal reduction<div class="ingroups"><a class="el" href="group__dense.html">Dense linear algebra</a> &raquo; <a class="el" href="group__group__svd.html">Singular Value Decomposition (SVD)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c2217286969d167984e3f1d5cc27875"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ungbr.html#ga3c2217286969d167984e3f1d5cc27875">magma_cungbr</a> (magma_vect_t vect, magma_int_t m, magma_int_t n, magma_int_t k, magmaFloatComplex *A, magma_int_t lda, magmaFloatComplex *tau, magmaFloatComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:ga3c2217286969d167984e3f1d5cc27875"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUNGBR generates one of the complex unitary matrices Q or P**H determined by CGEBRD when reducing a complex matrix A to bidiagonal form: A = Q * B * P**H.  <a href="#ga3c2217286969d167984e3f1d5cc27875">More...</a><br /></td></tr>
<tr class="separator:ga3c2217286969d167984e3f1d5cc27875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb057b650e298e12007fb33fefb59b6e"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ungbr.html#gadb057b650e298e12007fb33fefb59b6e">magma_dorgbr</a> (magma_vect_t vect, magma_int_t m, magma_int_t n, magma_int_t k, double *A, magma_int_t lda, double *tau, double *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gadb057b650e298e12007fb33fefb59b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DORGBR generates one of the real orthogonal matrices Q or P**H determined by DGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**H.  <a href="#gadb057b650e298e12007fb33fefb59b6e">More...</a><br /></td></tr>
<tr class="separator:gadb057b650e298e12007fb33fefb59b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38931ac70cf3234915215fcae1db3b0"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ungbr.html#gaa38931ac70cf3234915215fcae1db3b0">magma_sorgbr</a> (magma_vect_t vect, magma_int_t m, magma_int_t n, magma_int_t k, float *A, magma_int_t lda, float *tau, float *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaa38931ac70cf3234915215fcae1db3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SORGBR generates one of the real orthogonal matrices Q or P**H determined by SGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**H.  <a href="#gaa38931ac70cf3234915215fcae1db3b0">More...</a><br /></td></tr>
<tr class="separator:gaa38931ac70cf3234915215fcae1db3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8094b5bcfc3c534245923538aa28c8"><td class="memItemLeft" align="right" valign="top">magma_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magma__ungbr.html#gaea8094b5bcfc3c534245923538aa28c8">magma_zungbr</a> (magma_vect_t vect, magma_int_t m, magma_int_t n, magma_int_t k, magmaDoubleComplex *A, magma_int_t lda, magmaDoubleComplex *tau, magmaDoubleComplex *work, magma_int_t lwork, magma_int_t *info)</td></tr>
<tr class="memdesc:gaea8094b5bcfc3c534245923538aa28c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ZUNGBR generates one of the complex unitary matrices Q or P**H determined by ZGEBRD when reducing a complex matrix A to bidiagonal form: A = Q * B * P**H.  <a href="#gaea8094b5bcfc3c534245923538aa28c8">More...</a><br /></td></tr>
<tr class="separator:gaea8094b5bcfc3c534245923538aa28c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3c2217286969d167984e3f1d5cc27875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_cungbr </td>
          <td>(</td>
          <td class="paramtype">magma_vect_t&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaFloatComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CUNGBR generates one of the complex unitary matrices Q or P**H determined by CGEBRD when reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. </p>
<p>Q and P**H are defined as products of elementary reflectors H(i) or G(i) respectively.</p>
<p>If VECT = MagmaQ, A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an M-by-M matrix.</p>
<p>If VECT = MagmaP, A is assumed to have been a K-by-N matrix, and P**H is of order N: if k &lt; n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m rows of P**H, where n &gt;= m &gt;= k; if k &gt;= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as an N-by-N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vect</td><td>magma_vect_t Specifies whether the matrix Q or the matrix P**H is required, as defined in the transformation applied by CGEBRD: = MagmaQ: generate Q; = MagmaP: generate P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>magma_int_t The number of rows of the matrix Q or P**H to be returned. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>magma_int_t The number of columns of the matrix Q or P**H to be returned. N &gt;= 0. If VECT = MagmaQ, M &gt;= N &gt;= min(M,K); if VECT = MagmaP, N &gt;= M &gt;= min(N,K).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>magma_int_t If VECT = MagmaQ, the number of columns in the original M-by-K matrix reduced by CGEBRD. If VECT = MagmaP, the number of rows in the original K-by-N matrix reduced by CGEBRD. K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>magmaFloatComplex array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by CGEBRD. On exit, the M-by-N matrix Q or P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>magma_int_t The leading dimension of the array A. LDA &gt;= M.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>magmaFloatComplex array, dimension (min(M,K)) if VECT = MagmaQ (min(N,K)) if VECT = MagmaP TAU(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**H, as returned by CGEBRD in its array argument TAUQ or TAUP.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>magmaFloatComplex array, dimension (MAX(1,LWORK)) On exit, if *info = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>magma_int_t The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)). For optimum performance LWORK &gt;= min(M,N)*NB, where NB is the optimal blocksize.</td></tr>
  </table>
  </dd>
</dl>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>magma_int_t<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadb057b650e298e12007fb33fefb59b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_dorgbr </td>
          <td>(</td>
          <td class="paramtype">magma_vect_t&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DORGBR generates one of the real orthogonal matrices Q or P**H determined by DGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**H. </p>
<p>Q and P**H are defined as products of elementary reflectors H(i) or G(i) respectively.</p>
<p>If VECT = MagmaQ, A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an M-by-M matrix.</p>
<p>If VECT = MagmaP, A is assumed to have been a K-by-N matrix, and P**H is of order N: if k &lt; n, P**H = G(k) . . . G(2) G(1) and DORGBR returns the first m rows of P**H, where n &gt;= m &gt;= k; if k &gt;= n, P**H = G(n-1) . . . G(2) G(1) and DORGBR returns P**H as an N-by-N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vect</td><td>magma_vect_t Specifies whether the matrix Q or the matrix P**H is required, as defined in the transformation applied by DGEBRD: = MagmaQ: generate Q; = MagmaP: generate P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>magma_int_t The number of rows of the matrix Q or P**H to be returned. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>magma_int_t The number of columns of the matrix Q or P**H to be returned. N &gt;= 0. If VECT = MagmaQ, M &gt;= N &gt;= min(M,K); if VECT = MagmaP, N &gt;= M &gt;= min(N,K).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>magma_int_t If VECT = MagmaQ, the number of columns in the original M-by-K matrix reduced by DGEBRD. If VECT = MagmaP, the number of rows in the original K-by-N matrix reduced by DGEBRD. K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>double array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by DGEBRD. On exit, the M-by-N matrix Q or P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>magma_int_t The leading dimension of the array A. LDA &gt;= M.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>double array, dimension (min(M,K)) if VECT = MagmaQ (min(N,K)) if VECT = MagmaP TAU(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**H, as returned by DGEBRD in its array argument TAUQ or TAUP.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>double array, dimension (MAX(1,LWORK)) On exit, if *info = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>magma_int_t The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)). For optimum performance LWORK &gt;= min(M,N)*NB, where NB is the optimal blocksize.</td></tr>
  </table>
  </dd>
</dl>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>magma_int_t<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa38931ac70cf3234915215fcae1db3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_sorgbr </td>
          <td>(</td>
          <td class="paramtype">magma_vect_t&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SORGBR generates one of the real orthogonal matrices Q or P**H determined by SGEBRD when reducing a real matrix A to bidiagonal form: A = Q * B * P**H. </p>
<p>Q and P**H are defined as products of elementary reflectors H(i) or G(i) respectively.</p>
<p>If VECT = MagmaQ, A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an M-by-M matrix.</p>
<p>If VECT = MagmaP, A is assumed to have been a K-by-N matrix, and P**H is of order N: if k &lt; n, P**H = G(k) . . . G(2) G(1) and SORGBR returns the first m rows of P**H, where n &gt;= m &gt;= k; if k &gt;= n, P**H = G(n-1) . . . G(2) G(1) and SORGBR returns P**H as an N-by-N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vect</td><td>magma_vect_t Specifies whether the matrix Q or the matrix P**H is required, as defined in the transformation applied by SGEBRD: = MagmaQ: generate Q; = MagmaP: generate P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>magma_int_t The number of rows of the matrix Q or P**H to be returned. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>magma_int_t The number of columns of the matrix Q or P**H to be returned. N &gt;= 0. If VECT = MagmaQ, M &gt;= N &gt;= min(M,K); if VECT = MagmaP, N &gt;= M &gt;= min(N,K).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>magma_int_t If VECT = MagmaQ, the number of columns in the original M-by-K matrix reduced by SGEBRD. If VECT = MagmaP, the number of rows in the original K-by-N matrix reduced by SGEBRD. K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>float array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by SGEBRD. On exit, the M-by-N matrix Q or P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>magma_int_t The leading dimension of the array A. LDA &gt;= M.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>float array, dimension (min(M,K)) if VECT = MagmaQ (min(N,K)) if VECT = MagmaP TAU(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**H, as returned by SGEBRD in its array argument TAUQ or TAUP.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>float array, dimension (MAX(1,LWORK)) On exit, if *info = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>magma_int_t The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)). For optimum performance LWORK &gt;= min(M,N)*NB, where NB is the optimal blocksize.</td></tr>
  </table>
  </dd>
</dl>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>magma_int_t<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea8094b5bcfc3c534245923538aa28c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">magma_int_t magma_zungbr </td>
          <td>(</td>
          <td class="paramtype">magma_vect_t&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magmaDoubleComplex *&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">magma_int_t *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ZUNGBR generates one of the complex unitary matrices Q or P**H determined by ZGEBRD when reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. </p>
<p>Q and P**H are defined as products of elementary reflectors H(i) or G(i) respectively.</p>
<p>If VECT = MagmaQ, A is assumed to have been an M-by-K matrix, and Q is of order M: if m &gt;= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n columns of Q, where m &gt;= n &gt;= k; if m &lt; k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an M-by-M matrix.</p>
<p>If VECT = MagmaP, A is assumed to have been a K-by-N matrix, and P**H is of order N: if k &lt; n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m rows of P**H, where n &gt;= m &gt;= k; if k &gt;= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as an N-by-N matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vect</td><td>magma_vect_t Specifies whether the matrix Q or the matrix P**H is required, as defined in the transformation applied by ZGEBRD: = MagmaQ: generate Q; = MagmaP: generate P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>magma_int_t The number of rows of the matrix Q or P**H to be returned. M &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>magma_int_t The number of columns of the matrix Q or P**H to be returned. N &gt;= 0. If VECT = MagmaQ, M &gt;= N &gt;= min(M,K); if VECT = MagmaP, N &gt;= M &gt;= min(N,K).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>magma_int_t If VECT = MagmaQ, the number of columns in the original M-by-K matrix reduced by ZGEBRD. If VECT = MagmaP, the number of rows in the original K-by-N matrix reduced by ZGEBRD. K &gt;= 0.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>magmaDoubleComplex array, dimension (LDA,N) On entry, the vectors which define the elementary reflectors, as returned by ZGEBRD. On exit, the M-by-N matrix Q or P**H.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lda</td><td>magma_int_t The leading dimension of the array A. LDA &gt;= M.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>magmaDoubleComplex array, dimension (min(M,K)) if VECT = MagmaQ (min(N,K)) if VECT = MagmaP TAU(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q or P**H, as returned by ZGEBRD in its array argument TAUQ or TAUP.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">work</td><td>magmaDoubleComplex array, dimension (MAX(1,LWORK)) On exit, if *info = 0, WORK(1) returns the optimal LWORK.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lwork</td><td>magma_int_t The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)). For optimum performance LWORK &gt;= min(M,N)*NB, where NB is the optimal blocksize.</td></tr>
  </table>
  </dd>
</dl>
<p>If LWORK = -1, then a workspace query is assumed; the routine only calculates the optimal size of the WORK array, returns this value as the first entry of the WORK array, and no error message related to LWORK is issued by XERBLA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>magma_int_t<ul>
<li>= 0: successful exit</li>
<li>&lt; 0: if INFO = -i, the i-th argument had an illegal value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
